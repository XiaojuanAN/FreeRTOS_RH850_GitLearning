target_sources(${PROJECT_NAME}
    PRIVATE
    # {{BEGIN_TARGET_SOURCES}}
    ${CMAKE_CURRENT_LIST_DIR}/startup.s
    ${CMAKE_CURRENT_LIST_DIR}/vector.s
    # {{END_TARGET_SOURCES}}
)

# -mlong-calls:
# Treat all calls as being far away (near). If calls are assumed to be far away, the
# compiler always loads the functionâ€™s address into a register, and calls indirect
# through the pointer.
#
# see `gcc.pdf` `V850 Options` for details.
#
# JARL
# [Instruction format]
# (1) JARL disp22, reg2
# (2) JARL disp32, reg1
# (3) JARL [reg1], reg3
#
# c code:
# dummy();
#
# asm code generated by gcc without `-mlong-calls` is 22-bit addressing:
# jarl _dummy, lp
#
# asm code generated by gcc with `-mlong-calls` is 32-bit addressing:
# mov hilo(_dummy), r10
# jarl [r10], lp
#
# Therefore, if the address of the function dummy is larger than 0x3fffff (e.g. placed in ram),
# the `-mlong-calls` option must be added.
target_compile_options(${PROJECT_NAME}
    PUBLIC
    -mv850e3v5
    -msoft-float
    -fdata-sections
    -ffunction-sections
    -gdwarf-2
    -mlong-calls
)

set(LD_SCRIPT ${CMAKE_CURRENT_LIST_DIR}/r7f701013.ld)

target_link_options(${PROJECT_NAME}
    PUBLIC
    -mv850e3v5
    -nostartfiles
    -Wl,-T${LD_SCRIPT}
    -Wl,-Map,${PROJECT_NAME}.map
    -Wl,--gc-sections
    -Wl,--print-memory-usage
)
